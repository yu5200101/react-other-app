var e=e=>Array.isArray(e)?e:[e];function t(e){const t=Array.isArray(e[0])?e[0]:e;return function(e,t="expected all items to be functions, instead received the following types: "){if(!e.every((e=>"function"==typeof e))){const n=e.map((e=>"function"==typeof e?"function ".concat(e.name||"unnamed","()"):typeof e)).join(", ");throw new TypeError("".concat(t,"[").concat(n,"]"))}}(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}var n="undefined"!=typeof WeakRef?WeakRef:class{constructor(e){this.value=e}deref(){return this.value}};function o(e,t={}){let o={s:0,v:void 0,o:null,p:null};const{resultEqualityCheck:c}=t;let r,s=0;function l(){var t,l;let u=o;const{length:i}=arguments;for(let e=0,n=i;e<n;e++){const t=arguments[e];if("function"==typeof t||"object"==typeof t&&null!==t){let e=u.o;null===e&&(u.o=e=new WeakMap);const n=e.get(t);void 0===n?(u={s:0,v:void 0,o:null,p:null},e.set(t,u)):u=n}else{let e=u.p;null===e&&(u.p=e=new Map);const n=e.get(t);void 0===n?(u={s:0,v:void 0,o:null,p:null},e.set(t,u)):u=n}}const p=u;let a;if(1===u.s)a=u.v;else if(a=e.apply(null,arguments),s++,c){const e=null!=(l=null==(t=null==r?void 0:r.deref)?void 0:t.call(r))?l:r;null!=e&&c(e,a)&&(a=e,0!==s&&s--);r="object"==typeof a&&null!==a||"function"==typeof a?new n(a):a}return p.s=1,p.v=a,a}return l.clearCache=()=>{o={s:0,v:void 0,o:null,p:null},l.resetResultsCount()},l.resultsCount=()=>s,l.resetResultsCount=()=>{s=0},l}function c(n,...c){const r="function"==typeof n?{memoize:n,memoizeOptions:c}:n,s=(...n)=>{let c,s=0,l=0,u={},i=n.pop();"object"==typeof i&&(u=i,i=n.pop()),function(e,t="expected a function, instead received ".concat(typeof e)){if("function"!=typeof e)throw new TypeError(t)}(i,"createSelector expects an output function after the inputs, but received: [".concat(typeof i,"]"));const p={...r,...u},{memoize:a,memoizeOptions:f=[],argsMemoize:y=o,argsMemoizeOptions:d=[]}=p,v=e(f),m=e(d),h=t(n),b=a((function(){return s++,i.apply(null,arguments)}),...v),w=y((function(){l++;const e=function(e,t){const n=[],{length:o}=e;for(let c=0;c<o;c++)n.push(e[c].apply(null,t));return n}(h,arguments);return c=b.apply(null,e),c}),...m);return Object.assign(w,{resultFunc:i,memoizedResultFunc:b,dependencies:h,dependencyRecomputations:()=>l,resetDependencyRecomputations:()=>{l=0},lastResult:()=>c,recomputations:()=>s,resetRecomputations:()=>{s=0},memoize:a,argsMemoize:y})};return Object.assign(s,{withTypes:()=>s}),s}var r=c(o),s=Object.assign(((e,t=r)=>{!function(e,t="expected an object, instead received ".concat(typeof e)){if("object"!=typeof e)throw new TypeError(t)}(e,"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ".concat(typeof e));const n=Object.keys(e);return t(n.map((t=>e[t])),((...e)=>e.reduce(((e,t,o)=>(e[n[o]]=t,e)),{})))}),{withTypes:()=>s});export{r as c,o as w};
